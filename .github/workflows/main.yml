name: RDP (Persistent)

on:
  workflow_dispatch:

jobs:
  secure-rdp:
    runs-on: windows-latest
    timeout-minutes: 360

    steps:
      - name: Pre-Flight Verification (Hardening)
        shell: powershell
        run: |
          $secretsCount = 0
          if ("${{ secrets.TAILSCALE_AUTH_KEY }}") { Write-Host "✅ Tailscale Key Found"; $secretsCount++ }
          else { Write-Warning "❌ Tailscale Key Missing" }

          if ("${{ secrets.RCLONE_CONFIG }}") { Write-Host "✅ Rclone Config Found"; $secretsCount++ }
          else { Write-Warning "❌ Rclone Config Missing (Save/Restore will fail)" }

          if ("${{ secrets.GH_PAT }}") { Write-Host "✅ GH_PAT Found (Auto-Restart enabled)" }
          else { Write-Warning "⚠️ GH_PAT Missing (VM will only run 6 hours)" }

          if ($secretsCount -lt 2) { Write-Error "Critical secrets missing. Stopping to prevent data loss."; exit 1 }

      - name: Configure Core RDP Settings
        shell: powershell
        run: |
          # Enable RDP and optimize for speed
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0 -Force | Out-Null
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 0 -Force | Out-Null

          # Open firewall for RDP
          netsh advfirewall firewall delete rule name="RDP-Tailscale" 2>$null
          netsh advfirewall firewall add rule name="RDP-Tailscale" dir=in action=allow protocol=TCP localport=3389 | Out-Null
          Restart-Service -Name TermService -Force

      - name: Install Tools (Tailscale & Rclone)
        shell: powershell
        run: |
          # Rapid install using stable direct downloads
          $tsUrl = "https://pkgs.tailscale.com/stable/tailscale-setup-1.94.1.exe"
          $rcUrl = "https://downloads.rclone.org/rclone-current-windows-amd64.zip"

          # Install Tailscale
          Invoke-WebRequest -Uri $tsUrl -OutFile "$env:TEMP\tailscale.exe"
          Start-Process "$env:TEMP\tailscale.exe" -ArgumentList "/quiet" -Wait

          # Setup Rclone for Persistence
          Invoke-WebRequest -Uri $rcUrl -OutFile "$env:TEMP\rclone.zip"
          Expand-Archive -Path "$env:TEMP\rclone.zip" -DestinationPath "$env:TEMP\rclone" -Force
          $rcPath = Get-ChildItem -Path "$env:TEMP\rclone" -Filter "rclone.exe" -Recurse | Select-Object -First 1
          Copy-Item $rcPath.FullName -Destination "C:\Windows\System32\rclone.exe" -Force

          # Cleanup installers
          Remove-Item "$env:TEMP\tailscale.exe", "$env:TEMP\rclone.zip" -Force

      - name: Setup Rclone Configuration
        shell: powershell
        run: |
          # Write the rclone config from secrets
          $configPath = [System.IO.Path]::Combine($env:AppData, "rclone", "rclone.conf")
          New-Item -ItemType Directory -Path (Split-Path $configPath) -Force | Out-Null
          Set-Content -Path $configPath -Value @"
          ${{ secrets.RCLONE_CONFIG }}
          "@

      - name: Restore Global State (Extended Persistence)
        shell: powershell
        run: |
          Write-Host "Checking for existing state on Drive..."
          if (-not "${{ secrets.RCLONE_CONFIG }}") { return }

          # Targets for persistence (Files + Settings)
          $targets = @("desktop", "documents", "tailscale-state", "appdata-state", "registry-state")
          foreach ($t in $targets) {
              $ext = if ($t -eq "registry-state") { "reg" } else { "zip" }
              if (rclone ls "drive:$t.$ext" 2>$null) {
                  Write-Host "Restoring $t..."
                  try {
                      rclone copy "drive:$t.$ext" .
                      if ($t -eq "registry-state") {
                          reg import "$t.reg"
                      } elseif ($t -eq "appdata-state") {
                          Expand-Archive -Path "$t.zip" -DestinationPath "C:\temp-restore\AppData" -Force
                          Copy-Item "C:\temp-restore\AppData\*" $env:APPDATA -Recurse -Force -ErrorAction SilentlyContinue
                      } elseif ($t -eq "tailscale-state") {
                          Expand-Archive -Path "$t.zip" -DestinationPath "C:\temp-restore\$t" -Force
                          Copy-Item "C:\temp-restore\$t\*" "$env:ProgramData\Tailscale" -Recurse -Force
                      } else {
                          Expand-Archive -Path "$t.zip" -DestinationPath "C:\temp-restore\$t" -Force
                          $dest = [System.IO.Path]::Combine($env:USERPROFILE, $t.Replace("-state",""))
                          Copy-Item "C:\temp-restore\$t\*" $dest -Recurse -Force
                      }
                      Write-Host "✅ $t restored successfully."
                  } catch {
                      Write-Warning "⚠️ Failed to restore $t: $_"
                  }
                  Remove-Item "$t.$ext" -Force -ErrorAction SilentlyContinue
              }
          }

      - name: Create Managed VPS User
        shell: powershell
        run: |
          # Use requested secure password generation
          Add-Type -AssemblyName System.Security
          $charSet = @{
              Upper   = [char[]](65..90); Lower = [char[]](97..122); 
              Number  = [char[]](48..57); Special = [char[]](33..47)
          }
          $rawPassword = @()
          $rawPassword += $charSet.Upper | Get-Random -Count 4
          $rawPassword += $charSet.Lower | Get-Random -Count 4
          $rawPassword += $charSet.Number | Get-Random -Count 4
          $rawPassword += $charSet.Special | Get-Random -Count 4
          $password = -join ($rawPassword | Sort-Object { Get-Random })

          $securePass = ConvertTo-SecureString $password -AsPlainText -Force
          if (Get-LocalUser -Name "RDP" -ErrorAction SilentlyContinue) { Remove-LocalUser -Name "RDP" }
          New-LocalUser -Name "RDP" -Password $securePass -AccountNeverExpires
          Add-LocalGroupMember -Group "Administrators" -Member "RDP"
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member "RDP"

          "RDP_PASSWORD=$password" | Add-Content -Path $env:GITHUB_ENV

      - name: Establish Connection (Tailscale)
        shell: powershell
        run: |
          $tsExe = "$env:ProgramFiles\Tailscale\tailscale.exe"

          # Bring up Tailscale (Login is reused if restored)
          & $tsExe up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=gh-runner-persistent

          $tsIP = $null; $retries = 0
          while (-not $tsIP -and $retries -lt 12) {
              $tsIP = & $tsExe ip -4; if ($tsIP) { break }; Start-Sleep -Seconds 5; $retries++
          }
          if (-not $tsIP) { Write-Error "Tailscale IP failed"; exit 1 }
          "TAILSCALE_IP=$tsIP" | Add-Content -Path $env:GITHUB_ENV

      - name: Work Session (Loop with Auto-Restart)
        shell: powershell
        run: |
          Write-Host "`n=== RDP LOGIN DETAILS ==="
          Write-Host "IP: $env:TAILSCALE_IP"
          Write-Host "User: RDP"
          Write-Host "Pass: $env:RDP_PASSWORD"
          Write-Host "=========================`n"

          # Timer for Daisy Chain (5 hours 45 mins = 20700 seconds)
          $timerSeconds = 20700
          Write-Host "Session active. Auto-restart triggered in 5 hours 45 minutes..."
          
          # Sleep in increments to avoid hanging
          $elapsed = 0
          while ($elapsed -lt $timerSeconds) {
              Start-Sleep -Seconds 300
              $elapsed += 300
          }

          # Trigger Next Run (Daisy Chain)
          Write-Host "Triggering next run via API..."
          $repo = "$env:GITHUB_REPOSITORY"
          $token = "${{ secrets.GH_PAT }}"

          if ($token) {
              $url = "https://api.github.com/repos/$repo/actions/workflows/main.yml/dispatches"
              $body = @{ ref = "main" } | ConvertTo-Json
              $headers = @{
                  "Authorization" = "token $token"
                  "Accept"        = "application/vnd.github.v3+json"
              }
              try {
                  Invoke-RestMethod -Uri $url -Method Post -Headers $headers -Body $body
                  Write-Host "Successfully triggered next run."
              } catch {
                  Write-Warning "Failed to trigger run: $_"
              }
          }

      - name: Save Global State (Fail-Safe Policy)
        if: always()
        shell: powershell
        run: |
          Write-Host "Saving state for persistence..."
          if (-not "${{ secrets.RCLONE_CONFIG }}") { return }

          # 1. Save Tailscale state
          try {
              $tsState = "$env:ProgramData\Tailscale"
              if (Test-Path $tsState) {
                  Compress-Archive -Path "$tsState\*" -DestinationPath "tailscale-state.zip" -Force
                  rclone copy "tailscale-state.zip" "drive:"
              }
          } catch { Write-Warning "Tailscale save failed: $_" }

          # 2. Save Registry Settings (User Software Hive)
          try {
              reg export "HKCU\Software" "registry-state.reg" /y
              rclone copy "registry-state.reg" "drive:"
          } catch { Write-Warning "Registry save failed: $_" }

          # 3. Save AppData (Roaming) - Only high-value folders
          try {
              if (Test-Path $env:APPDATA) {
                  Compress-Archive -Path "$env:APPDATA\*" -DestinationPath "appdata-state.zip" -Force -ErrorAction SilentlyContinue
                  rclone copy "appdata-state.zip" "drive:"
              }
          } catch { Write-Warning "AppData save failed: $_" }

          # 4. Save User Folders (Desktop, Documents)
          $userFolders = @("Desktop", "Documents")
          foreach ($folder in $userFolders) {
              try {
                  $source = [System.IO.Path]::Combine($env:USERPROFILE, $folder)
                  if (Test-Path $source) {
                      Compress-Archive -Path "$source\*" -DestinationPath "$($folder.ToLower())-state.zip" -Force
                      rclone copy "$($folder.ToLower())-state.zip" "drive:"
                  }
              } catch { Write-Warning "$folder save failed: $_" }
          }
          Write-Host "State backup completed."
